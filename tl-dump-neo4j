#!/usr/bin/env perl
# Copyright 2018 Norbert Preining
# This file is licensed under the GNU General Public License version 2
# or any later version.
# 
# Outputs files that can be imported into a Neo4j database using neo4j-import
#
# TODO
# for now we ignore .win32 packages
# Cannot find uuid for dependency texlive.infra
# Cannot find uuid for dependency texlive.infra
# Cannot find uuid for dependency texlive.infra
# Cannot find uuid for dependency dviout.win32
# Cannot find uuid for dependency wintools.win32


my $Master;

BEGIN {
  $^W = 1;
  unshift (@INC, "./tlpkg");
}

use strict;
use TeXLive::TLPOBJ;
use TeXLive::TLPDB;
use TeXLive::TLUtils;
use Getopt::Long;
use File::Path qw/make_path/;

my $opt_initial = 0;
my $opt_output  = "./out";

GetOptions(
  "initial!" => \$opt_initial,
  "output=s" => \$opt_output,
) or die "Cannot parse command line: $!";


exit (&main());


sub main
{
  my %pkgs;
  my %fls;

  my $idstr = ($opt_initial ? ":ID" : "");
  my $intstr = ($opt_initial ? ":int" : "");

  my $tlpdb = TeXLive::TLPDB->new();
  $tlpdb->from_file($ARGV[0], verify => 0, media => "local_uncompressed");
  die "Cannot init tlpdb from $ARGV[0] ..." unless defined($tlpdb);

  # try to get basic information of tlpdb
  my $tlpdbrevision = $tlpdb->config_revision;
  if (! $tlpdbrevision) {
    print STDERR "Cannot find revision of TLPDB, bailing out!\n";
    exit 1;
  }

  foreach my $pkg ($tlpdb->list_packages) {
    next if ($pkg =~ m/^00texlive/);  # ignore internal pkgs.
    # ignore *all* arch dep pacakges (also tlpsv etc.)
    next if ($pkg =~ m/\./);

    my $tlp = $tlpdb->get_package($pkg);
    if (!defined($tlp)) {
      warn "strange, $pkg not found but listed, continuing anyway";
      next;
    }
   
    $pkgs{$pkg}{'category'} = $tlp->category;
    $pkgs{$pkg}{'revision'} = $tlp->revision;
    $pkgs{$pkg}{'depends'} = {};
    my @deps = $tlp->depends;
    for my $d (@deps) {
      $pkgs{$pkg}{'depends'}{$d} = 1;
    }

    # go over files
    for my $f ($tlp->docfiles) {
      $fls{$f}{'contained'}{$pkg} = 'doc';
    }
    for my $f ($tlp->runfiles) {
      $fls{$f}{'contained'}{$pkg} = 'run';
    }
    for my $f ($tlp->srcfiles) {
      $fls{$f}{'contained'}{$pkg} = 'src';
    }
    my %foo = %{$tlp->binfiles};
    for my $a (keys %foo) {
      for my $f (@{$foo{$a}}) {
        $fls{$f}{'contained'}{$pkg} = 'bin';
      }
    }
    $pkgs{$pkg}{'uuid'} = $pkg . ":" . $pkgs{$pkg}{'revision'};
  }

  if (! -d $opt_output) {
    make_path($opt_output) || die("Cannot create output directory $opt_output: $?");
  }
  my %fd;
  open($fd{'TLPDB'}, ">:encoding(UTF-8)", "$opt_output/node-TLPDB.csv") || die("Cannot open $opt_output/node-TLPDB.csv: $!");
  print { $fd{'TLPDB'} } "uuid$idstr,revision$intstr\n";
  print { $fd{'TLPDB'} } "tlpdb:$tlpdbrevision,$tlpdbrevision\n";

  for my $f (qw/Package Collection Scheme ConTeXt TLCore/) {
    open($fd{$f}, ">:encoding(UTF-8)", "$opt_output/node-$f.csv") || die("Cannot open $opt_output/node-$f.csv: $!");
    print { $fd{$f} } "uuid$idstr,name,revision$intstr\n";
  }
  open($fd{'File'}, ">:encoding(UTF-8)", "$opt_output/node-File.csv") || die("Cannot open $opt_output/node-File.csv: $!");
  print { $fd{'File'} } "name$idstr\n";
  open($fd{'depends'}, ">:encoding(UTF-8)", "$opt_output/edge-depends.csv") || die("Cannot open $opt_output/edge-depends.csv: $!");
  print { $fd{'depends'} } ":START_ID,:END_ID\n";
  open($fd{'contains'}, ">:encoding(UTF-8)", "$opt_output/edge-contains.csv") || die("Cannot open $opt_output/edge-contains.csv: $!");
  print { $fd{'contains'} } ":START_ID,:END_ID\n";
  open($fd{'includes'}, ">:encoding(UTF-8)", "$opt_output/edge-includes.csv") || die("Cannot open $opt_output/edge-includes.csv: $!");
  print { $fd{'includes'} } ":START_ID,type,:END_ID\n";


  for my $pkg (keys %pkgs) {
    my $cat = $pkgs{$pkg}{'category'};
    my $uid = $pkgs{$pkg}{'uuid'};
    my $ver = $pkgs{$pkg}{'revision'};
    print { $fd{$cat} } "$uid,$pkg,$ver\n";
    print { $fd{'contains'} } "tlpdb:$tlpdbrevision,$uid\n";
    for my $dep (keys %{$pkgs{$pkg}{'depends'}}) {
      next if ($dep =~ m/\.ARCH$/);
      my $depuuid = $pkgs{$dep}{'uuid'};
      if ($depuuid) {
          print { $fd{'depends'} } "$uid,$depuuid\n";
      } else {
        warn("Cannot find uuid for dependency $dep\n");
      }
    }
  }

  for my $f (keys %fls) {
    print { $fd{'File'} } "\"$f\"\n";
    for my $pkg (keys %{$fls{$f}{'contained'}}) {
      my $cuuid = $pkgs{$pkg}{'uuid'};
      if ($cuuid) {
        my $t = $fls{$f}{'contained'}{$pkg};
        print { $fd{'includes'} } "$cuuid,$t,\"$f\"\n";
      } else {
        warn("Cannot find uuid for dependency $pkg for file $f\n");
      }
    }
  }


  for my $fd (keys %fd) {
    close($fd{$fd}) || warn "Cannot close fd for $fd: $!";
  }
}

__END__

### Local Variables:
### perl-indent-level: 2
### tab-width: 2
### indent-tabs-mode: nil
### End:
# vim:set tabstop=2 expandtab: #
